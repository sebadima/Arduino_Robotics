/* By Chris Anderson, Jordi Munoz, modified by Harald Molle for use on model boats */
/* Nov/27/2010
/* Version 1.1 */
/* Released under an Apache 2.0 open source license*/
/* Project home page is at DIYdrones.com (and ArduPilot.com)
/* We hope you improve the code and share it with us at DIY Drones!*/
#include "defines.h"
#include "waypoints.h"
// Global variables definition
int waypoints; // waypoint counter
unsigned int integrator_reset_counter = 0; // counter variable (in seconds) for the
Integrator holdoff-time after a waypoint switch
byte current_wp = 0; //This variable stores the actual waypoint we are trying to reach.
int wp_bearing = 0; //Bearing to the current waypoint (in degrees)
unsigned int wp_distance = 0; // Distance to the current waypoint (in meters)
//GPS obtained information
float lat = 0; //Current Latitude
float lon = 0; //Current Longitude
unsigned long time; // curent UTC time
float ground_speed = 0; // Speed over ground
int course = 0; // Course over ground
int alt = 0; //Altitude above sea
 
 
// Flag variables
byte jumplock_wp = 0; // When switching waypoints this lock will allow only one transition.
byte gps_new_data_flag = 0; // A simple flag to know when we've got new gps data.
// rudder setpoint variable, holds the calculated value for the rudder servo
int rudder_setpoint = 0;
byte fix_position = 0; // Flag variable for valid gps position
// Arduino Startup, entry point after power-on
void setup()
{
init_ardupilot(); // Initialize the hardware specific peripherals
waypoints = sizeof(wps) / sizeof(LONLAT); // calculate the number of waypoints
Init_servo(); //Initalize the servos, see "Servo_Control" tab.
test_rudder(); //Just move the servo to see that there is something living
bldc_arm_throttle(); // Initialize the BLDC controller
print_header(); //print the header line on the debug channel
delay(500); // wait until UART Tx Buffer is surely purged
init_startup_parameters(); // Wait for first GPS Fix
test_rudder(); // Move rudder-servo to see that the launch-time is close
bldc_start_throttle(); // start the motor
delay (5000); // go the first five seconds without GPS control to get the direction vector
stabilized
init_startup_parameters(); // re-synchronize GPS
}
// Program main loop starts here
// Arduino main loop
void loop()
{
gps_parse_nmea(); // parse incoming NMEA Messages from GPS Module and store relevant data in
global variables
if((gps_new_data_flag & 0x01) == 0x01) //Checking new GPS "GPRMC" data flag in position
{


digitalWrite(YELLOW_LED, HIGH); // pulse the yellow LED to indicate a received GPS
sentence
gps_new_data_flag &= (~0x01); //Clearing new data flag...
rudder_control(); // Control function for steering the course to next waypoint
if (integrator_reset_counter++ < WP_TIMEOUT) // Force I and D part to zero for
WP_TIMEOUT seconds after each waypoint switch
reset_PIDs();
send_to_ground(); /*Print values on datalogger, if attached, just for debugging*/
} // end if gps_new_data...
// Ensure that the autopilot will jump ONLY ONE waypoint
if((wp_distance < WP_RADIUS) && (jumplock_wp == 0x00)) //Checking if the waypoint distance
is less than WP_RADIUS m, and check if the lock is open
{
current_wp++; //Switch the waypoint
jumplock_wp = 0x01; //Lock the waypoint switcher.
integrator_reset_counter = 0;
if(current_wp >= waypoints) // Check if we've passed all the waypoints, if yes stop
motor
finish_mission();
} // end if wp_distance...
digitalWrite(YELLOW_LED,LOW); //Turning off the status LED
} // end loop ()
 
 
 
 
// PID Debug Variables
float pid_p;
float pid_i;
float pid_d;
float pid_dt;
int dbg_pid_error;
// Debugging output, sends the value of internal variables to the datalogger every second
// Floating point values are multiplied and converted to integers to get it through the
Serial.print function
void send_to_ground(void)
{
Serial.print(course);
Serial.print("\t");
Serial.print((int)wp_bearing);
Serial.print("\t");
Serial.print(dbg_pid_error);
Serial.print("\t");
Serial.print(wp_distance);
Serial.print("\t");
Serial.print(time);
Serial.print("\t");
Serial.print((int)rudder_setpoint);
Serial.print("\t");
Serial.print((int)current_wp);
Serial.print("\t");
Serial.print((int)pid_p);
Serial.print("\t");
Serial.print((int)pid_i);
Serial.print("\t");
Serial.print((int)pid_d);
Serial.print("\t");
ground_speed *= 18.0; // Scale miles/h to km/h * 10
Serial.print((int)ground_speed);
Serial.print("\t");
Serial.print(alt);
Serial.println();
}



// Debugging output, sends the value of internal variables to the datalogger once on startup
// Floating point values are multiplied and converted to integers to get it through the
Serial.print function
void print_header(void)
{
// Header for the System constants
Serial.println("KP_HEADING\t\t KI_HEADING\t\t KD_HEADING\t\t INTEGRATOR_MAX\t\t RAM");
delay(250);
Serial.print ((int)(KP_HEADING * 100));
Serial.print("\t\t");
Serial.print ((int)(KI_HEADING * 100));
Serial.print("\t\t");
CHAPTER 9 ? ROBOBOAT
374
Serial.print ((int)(KD_HEADING * 100));
Serial.print("\t\t");
Serial.print ((int)(INTEGRATOR_LIMIT));
Serial.print("\t\t");
Serial.println( ram_info() );
delay(250);
// header for the debugging variables
Serial.println("Act\t Setp\t err\t Dist\t Time\t Rudd\t WP\t pid_p\t pid_i\t pid_d\t speed\t
alt");
delay (250);
}
// function to calculate the remaining amount of RAM in Bytes
// Check always, if you have changed the Waypoint array (see the Header of the debug-output)
int ram_info()
{
uint8_t *heapptr;
uint8_t *stackptr;
stackptr = (uint8_t *)malloc(4); // use stackptr temporarily
heapptr = stackptr;  // save value of heap pointer
free(stackptr);  // free up the memory again (sets stackptr to 0)
stackptr = (uint8_t *)(SP); // save value of stack pointer
return ((int) stackptr - (int) heapptr);
}
Init Module
This tab contains all initialization functions for the hardware (Listing 9-3).
Listing 9-3. Init.pde
void init_ardupilot(void)
{
gps_init_baudrate();
Serial.begin(9600);
//Declaring pins
pinMode(5,INPUT); // Mode pin (not used)
pinMode(11,OUTPUT); // Simulator Output pin (not used)
pinMode(MUX_PIN,OUTPUT); //MUX pin, applies only to modified Hardware !
pinMode(BLUE_LED,OUTPUT); // LOCK LED pin in ardupilot board, indicates valid GPS data
pinMode(YELLOW_LED,OUTPUT);// Status LED, blinks, when valid satellite fix data is received
pinMode(SERVO1_IN_PIN,INPUT); // Throttle input from RC Rx (only used for RC control)
CHAPTER 9 ? ROBOBOAT
375
pinMode(SERVO2_IN_PIN,INPUT); // Rudder input from RC Rx (only used for RC control)
#ifdef RADIO_CONTROL
init_RC_control(); // Initialize Radio control
#endif
switch_to_ardupilot(); // default servo control by Ardupilot
}
void init_startup_parameters(void)
{
//yeah a do-while loop, checks over and over again until we have valid GPS position and lat
is diferent from zero.
//I re-verify the Lat because sometimes fails and sets home lat as zero. This way never goes
wrong..
do
{
gps_parse_nmea(); //Reading and parsing GPS data
}
while(((fix_position < 0x01) || (lat == 0)));
//Another verification
gps_new_data_flag=0;
do
{
gps_parse_nmea(); //Reading and parsing GPS data
}
while((gps_new_data_flag&0x01 != 0x01) & (gps_new_data_flag&0x02 != 0x02));
rudder_control(); //I've put this here because i need to calculate the distance to the next
waypoint, otherwise it will start at waypoint 2.
}


Listing 9-4. Navigation.pde
// Variables used by the NMEA Parser
char buffer[90]; //Serial buffer to catch GPS data
/*GPS Pointers*/
char *token;
char *search = ",";
char *brkb, *pEnd;
CHAPTER 9 ? ROBOBOAT
376
/*************************************************************************
* This functions parses the NMEA strings...
* Pretty complex but never fails and works well with all GPS modules and baud speeds.. :-)
* Just change the Serial.begin() value in the first tab for higher baud speeds
*************************************************************************/
void gps_parse_nmea(void)
{
const char head_rmc[]="GPRMC"; //GPS NMEA header to look for
const char head_gga[]="GPGGA"; //GPS NMEA header to look for
static byte unlock=1; //some kind of event flag
static byte checksum=0; //the checksum generated
static byte checksum_received=0; //Checksum received
static byte counter=0; //general counter
//Temporary variables for some tasks, specially used in the GPS parsing part
unsigned long temp=0;
unsigned long temp2=0;
unsigned long temp3=0;
while(Serial.available() > 0)
{
if(unlock==0)
{
buffer[0]=Serial.read();//puts a byte in the buffer
if(buffer[0]=='$')//Verify if is the preamble $
{
unlock=1;
}
}
/*************************************************/
else
{
buffer[counter]=Serial.read();
if(buffer[counter]==0x0A)//Looks for \F
{
unlock=0;
if (strncmp (buffer, head_rmc, 5) == 0) // $GPRMC parsing starts here
{
/*Generating and parsing received checksum, */
for(int x=0; x<100; x++)
{
if(buffer[x]=='*')
CHAPTER 9 ? ROBOBOAT
377
{
checksum_received=strtol(&buffer[x+1],NULL,16);//Parsing received checksum...
break;
}
else
{
checksum ^= buffer[x]; //XOR the received data...
}
}
if(checksum_received == checksum)//Checking checksum
{
/* Token will point to the data between comma "'", returns the data in the order
received */
/*THE GPRMC order is: UTC, UTC status ,Lat, N/S indicator, Lon, E/W indicator,
speed, course, date, mode, checksum*/
token = strtok_r(buffer, search, &brkb); //Contains the header GPRMC, not used
token = strtok_r(NULL, search, &brkb); //UTC Time, not used
time = atol (token);
token = strtok_r(NULL, search, &brkb); //Valid UTC data? maybe not used...
//Longitude in degrees, decimal minutes. (ej. 4750.1234 degrees decimal minutes =
47.835390 decimal degrees)
//Where 47 are degrees and 50 the minutes and .1234 the decimals of the minutes.
//To convert to decimal degrees, divide the minutes by 60 (including decimals),
//Example: "50.1234/60=.835390", then add the degrees, ex: "47+.835390=47.835390"
decimal degrees
token = strtok_r(NULL, search, &brkb); //Contains Latitude in degrees decimal
minutes...
// Serial.println(token);
//taking only degrees, and minutes without decimals,
//strtol stop parsing till reach the decimal point "." result example 4750,
eliminates .1234
temp = strtol (token, &pEnd, 10);
//takes only the decimals of the minutes
//result example 1234.
temp2 = strtol (pEnd + 1, NULL, 10);
//joining degrees, minutes, and the decimals of minute, now without the point...
//Before was 4750.1234, now the result example is 47501234...
temp3 = (temp * 10000) + (temp2);
//modulo to leave only the decimal minutes, eliminating only the degrees..
//Before was 47501234, the result example is 501234.
temp3 = temp3 % 1000000;
CHAPTER 9 ? ROBOBOAT
378
//Dividing to obtain only the degrees, before was 4750
//The result example is 47 (4750/100=47)
temp /= 100;
//Joining everything and converting to float variable...
//First i convert the decimal minutes to degrees decimals stored in "temp3",
example: 501234/600000= .835390
//Then i add the degrees stored in "temp" and add the result from the first step,
example 47+.835390=47.835390
//The result is stored in "lat" variable...
lat=temp + ( (float)temp3 / 600000 );
token = strtok_r(NULL, search, &brkb); //lat, north or south?
//If the char is equal to S (south), multiply the result by -1..
if(*token == 'S')
{
lat = lat * -1;
}
//This the same procedure use in lat, but now for Lon....
token = strtok_r(NULL, search, &brkb);
// Serial.println(token);
temp = strtol (token, &pEnd, 10);
temp2 = strtol (pEnd + 1, NULL, 10);
temp3 = (temp * 10000) + (temp2);
temp3 = temp3 % 1000000;
temp /= 100;
lon=temp + ((float)temp3 / 600000);
token = strtok_r(NULL, search, &brkb); //lon, east or west?
if(*token == 'W')
{
lon=lon * -1;
}
token = strtok_r(NULL, search, &brkb); //Speed overground?
ground_speed = atof(token);
token = strtok_r(NULL, search, &brkb); //Course?
course= atoi(token);
gps_new_data_flag |= 0x01; //Update the flag to indicate the new data has arrived.
jumplock_wp=0x00;//clearing waypoint lock..
}
checksum=0;
} //End of the GPRMC parsing
CHAPTER 9 ? ROBOBOAT
379
if (strncmp (buffer,head_gga,5) == 0) // $GPGGA parsing starts here
{
/*Generating and parsing received checksum, */
for(int x=0; x<100; x++)
{
if(buffer[x] == '*')
{
checksum_received = strtol(&buffer[x+1], NULL, 16);//Parsing received
checksum...
break;
}
else
{
checksum ^= buffer[x]; //XOR the received data...
}
}
if(checksum_received == checksum)//Checking checksum
{
token = strtok_r(buffer, search, &brkb);//GPGGA header, not used anymore
token = strtok_r(NULL, search, &brkb);//UTC, not used!!
token = strtok_r(NULL, search, &brkb);//lat, not used!!
token = strtok_r(NULL, search, &brkb);//north/south, nope...
token = strtok_r(NULL, search, &brkb);//lon, not used!!
token = strtok_r(NULL, search, &brkb);//wets/east, nope
token = strtok_r(NULL, search, &brkb);//Position fix, used!!
fix_position = atoi(token);
token = strtok_r(NULL, search, &brkb); //sats in use!! Nein...
token = strtok_r(NULL, search, &brkb);//HDOP, not needed
token = strtok_r(NULL, search, &brkb);//ALTITUDE, is the only meaning of this
string.. in meters of course.
alt = atoi(token);
if(alt < 0)
{
alt = 0;
}
if(fix_position >= 0x01)
digitalWrite(BLUE_LED,HIGH); //Status LED...
else
digitalWrite(BLUE_LED,LOW);
gps_new_data_flag |= 0x02; //Update the flag to indicate the new data has arrived.
}
checksum=0; //Restarting the checksum
} // end of $GPGGA parsing
for(int a=0; a<=counter; a++)//restarting the buffer
{
buffer[a]=0;
}
CHAPTER 9 ? ROBOBOAT
380
counter=0; //Restarting the counter
}
else
{
counter++; //Incrementing counter
}
}
}
}
/*************************************************************************
* //Function to calculate the course between two waypoints
* //I'm using the real formulas--no lookup table fakes!
*************************************************************************/
int get_gps_course(float flat1, float flon1, float flat2, float flon2)
{
float calc;
float bear_calc;
float x = 69.1 * (flat2 - flat1);
float y = 69.1 * (flon2 - flon1) * cos(flat1/57.3);
calc=atan2(y,x);
bear_calc= degrees(calc);
if(bear_calc<=1){
bear_calc=360+bear_calc;
}
return bear_calc;
}
/*************************************************************************
* //Function to calculate the distance between two waypoints
* //I'm using the real formulas
*************************************************************************/
unsigned int get_gps_dist(float flat1, float flon1, float flat2, float flon2)
{
float x = 69.1 * (flat2 - flat1);
float y = 69.1 * (flon2 - flon1) * cos(flat1/57.3);
return (float)sqrt((float)(x*x) + (float)(y*y))*1609.344;
}
/***************************************************************************/
//Computes heading the error, and choose the shortest way to reach the desired heading
/***************************************************************************/
int compass_error(int PID_set_Point, int PID_current_Point)
{
float PID_error=0;//Temporary variable
CHAPTER 9 ? ROBOBOAT
381
if(fabs(PID_set_Point-PID_current_Point) > 180)
{
if(PID_set_Point-PID_current_Point < -180)
{
PID_error=(PID_set_Point+360)-PID_current_Point;
}
else
{
PID_error=(PID_set_Point-360)-PID_current_Point;
}
}
else
{
PID_error=PID_set_Point-PID_current_Point;
}
return PID_error;
}
// This function stops all activity and will never return
// This is the end...
void finish_mission(void)
{
bldc_stop_throttle();
#ifdef RADIO_CONTROL
switch_to_radio(); // Give control back to Radio
#endif
while (1) // loop forever, if timeout reached (and start to swim and recover the boat)
{
digitalWrite(YELLOW_LED,LOW); // Fast flashing Yellow LED to indicate arrival
delay(100);
digitalWrite(YELLOW_LED,HIGH);
delay(100);
}
}
/*************************************************************************
* rudder Control, reads gps info, calculates navigation, executes PID and sends values to the
servo..
*************************************************************************/
void rudder_control(void)
{
wp_bearing=get_gps_course(lat, lon, wps[current_wp].lat, wps[current_wp].lon);//Calculating
Bearing, this function is located in the GPS_Navigation tab..
wp_distance = get_gps_dist(lat, lon, wps[current_wp].lat, wps[current_wp].lon);
//Calculating Distance, this function is located in the GPS_Navigation tab..
CHAPTER 9 ? ROBOBOAT
382
rudder_setpoint = MIDDLE_RUDDER+PID_heading(compass_error(wp_bearing, course)); //Central
Position + PID(compass_error(desired course, current course)).
pulse_servo_rudder((long)rudder_setpoint); //Sending values to servo, 90 degrees is central
position.
}
// This function switches the EM406 into 9600 Baud
// Normally, the EM406 defaults to NMEA and 4800 Baud after long power-OFF times
void gps_init_baudrate(void)
{
Serial.begin(4800); // Always try in 4800 Baud first.
delay(100);
Serial.println("$PSRF100,1,9600,8,1,0*0D"); // command to switch SIRFIII to NMEA, 9600,
8, N, 1
delay(100);
Serial.begin(9600); // switch finally back to 9600 Baud
}
PID_control Module
This tab contains the function that does the control loop for the straight line navigation (Listing 9-5).
This is one of the most important modules, because it uses a PID algorithm that is implemented in a very
simple manner. The behavior of the PID loop is controlled by constants that are described in the section
“The PID Constants.”
Listing 9-5. PID_Control.pde
//PID loop variables
int heading_previous_error;
float heading_I = 0.0; //Stores the result of the integrator
/****************************************************************************************
* PID= P+I+D This function only works, when GPS with one second update is used.
***************************************************************/
int PID_heading(int PID_error)
{
static float heading_D; //Stores the result of the derivator
static float heading_output; //Stores the result of the PID loop
CHAPTER 9 ? ROBOBOAT
383
dbg_pid_error = PID_error; // deBug
heading_I += (float)PID_error;
heading_I = constrain(heading_I, -INTEGRATOR_LIMIT, INTEGRATOR_LIMIT); //Limit the PID
integrator...
//Derivation part
heading_D = ((float)PID_error - (float)heading_previous_error);
heading_output = 0.0;//Clearing the variable.
heading_output = (KP_HEADING * (float)PID_error); //Proportional part, is just the KP
constant * error.. and adding to the output
pid_p = (KP_HEADING * (float)PID_error);
heading_output += (KI_HEADING * heading_I); //Adding integrator result...
pid_i = (KI_HEADING * heading_I);
heading_output += (KD_HEADING * heading_D);// /Adding derivator result....
pid_d = (KD_HEADING * heading_D);
//Adds all the PID results and limit the output...
heading_output = constrain(heading_output, (float)HEADING_MIN,
(float)HEADING_MAX);//limiting the output....
heading_previous_error = PID_error;//Saving the actual error to use it later (in derivating
part)...
//Now checking if the user have selected normal or reverse mode (servo)...
if(REVERSE_RUDDER == 1)
{
return (int)(-1 * heading_output);
}
else
{
return (int)(heading_output);
}
}
/*************************************************************************
* Reset all the PIDs
*************************************************************************/
void reset_PIDs(void)
{
heading_previous_error = 0.0;
heading_I = 0.0;
}
CHAPTER 9 ? ROBOBOAT
384
Servo_control Module
This tab contains the functions that output the pulses to the rudder servo and to the ESC for the motor
(Listing 9-6). This module uses the pulse width modulation (PWM) unit of the AVR microcontroller that
is used on all Arduino platforms.
Listing 9-6. Servo_control.pde
/**************************************************************
* Configuring the PWM hadware... If you want to understand this,
* you must read the Data Sheet of atmega168..
* The following functionsare optimized for speed. The Arduino Servo library
* may not work, because it consumes more processing time than this ones
***************************************************************/
void Init_servo(void)//This part will configure the PWM to control the servo 100% by hardware,
and not waste CPU time..
{
digitalWrite(RUDDER,LOW);//Defining servo output pins
pinMode(RUDDER,OUTPUT);
digitalWrite(THROTTLE,LOW);
pinMode(THROTTLE,OUTPUT);
/*Timer 1 settings for fast PWM*/
//Note: these strange strings that follow, like OCRI1A, are actually predefined Atmega168
registers.
// We load the registers and the chip does the rest.
//Remember the registers not declared here remain zero by default...
TCCR1A =((1<<WGM11)|(1<<COM1B1)|(1<<COM1A1)); //Please read page 131 of DataSheet, we are
changing the registers settings of WGM11,COM1B1,COM1A1 to 1 thats all...
TCCR1B = (1<<WGM13)|(1<<WGM12)|(1<<CS11); //Prescaler set to 8, that give us a resolution of
2us, read page 134 of data sheet
OCR1A = 2000; //the period of servo 1, remember 2us resolution, 2000/2 = 1000us the pulse
period of the servo...
OCR1B = 3000; //the period of servo 2, 3000/2=1500 us, more or less is the central
position...
ICR1 = 40000; //50hz freq...Datasheet says (system_freq/prescaler)/target frequency. So
(16000000hz/8)/50hz=40000,
//must be 50hz because is the servo standard (every 20 ms, and 1hz = 1sec) 1000ms/20ms=50hz,
elementary school stuff...
}
/**************************************************************
* Function to pulse the throttle servo
***************************************************************/
void pulse_servo_throttle(long angle)//Will convert the angle to the equivalent servo
position...
{
//angle=constrain(angle,180,0);
CHAPTER 9 ? ROBOBOAT
385
OCR1A = ((angle * (MAX16_THROTTLE - MIN16_THROTTLE)) / 180L + MIN16_THROTTLE) * 2L;
}
/**************************************************************
* Function to pulse the yaw/rudder servo...
***************************************************************/
void pulse_servo_rudder(long angle) // converts the angle to the equivalent servo position...
{
OCR1B = ((angle *(MAX16_RUDDER - MIN16_RUDDER)) / 180L + MIN16_RUDDER) * 2L;
}
void bldc_arm_throttle(void) // "arm" the BLDC controller for the throttle
{
delay(2000);
bldc_stop_throttle(); // then switch to approx. zero, Servo controller armed
delay(4000);
}
void bldc_start_throttle(void) // brushless Motor (Multiplex controller)
{
pulse_servo_throttle(MOTOR_SPEED); // set Motor speed
}
// function to stop the Motor // brushless Motor (Multiplex controller)
void bldc_stop_throttle(void)
{
pulse_servo_throttle(MOTOR_OFF); // switch to approx. zero
}
void test_rudder(void)
{
pulse_servo_rudder(MIDDLE_RUDDER + HEADING_MIN);
delay(1500);
pulse_servo_rudder(MIDDLE_RUDDER + HEADING_MAX);
delay(1500);
pulse_servo_rudder(MIDDLE_RUDDER);
delay(1500);
}
// Module to control the ArduPilot via Radio Control (RC)
// You have to use an RC equipment, that supports a failsafe functionality
// e.g. if the Transmitter is switched OFF, on the receiver channel there should be
// "silence" (either HIGH or LOW level)
// I actually have tested this with a 2.4GHZ SPEKTRUM System.
// Analog Systems may always output some pulses due to erroneous received signals
// My cheap 27MHz Radio control did not work
// Please check thoroughly, before you make you first start!
CHAPTER 9 ? ROBOBOAT
386
// Function to Check, if there are pulses on the Rx rudder Input
// I took the rudder channel, because on the SPEKTRUM, the failsafe function
// outputs pulses on the throttle channel (default speed), when the Transmitter is OFF.
// This function checks for "silence" on the rudder channel.
// If there is silence, the Transmitter is switched OFF and the control should be given to
// the ArduPilot
// Return 0 if no pulse available (timeout > 25ms)
int check_radio(void)
{
return (int) pulseIn(SERVO2_IN_PIN, HIGH, 25000); // Check, if there are pulses on the Rx
rudder Input;
}
// Function to switch the Multiplexer to the ArduPilot
void switch_to_ardupilot (void)
{
digitalWrite(MUX_PIN,HIGH); // servos controlled by Ardupilot
}
// Function to switch the Multiplexer to the RC Receiver
void switch_to_radio (void)
{
digitalWrite(MUX_PIN,LOW); // servos controlled by Radio control
}
